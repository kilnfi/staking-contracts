{
  "language": "Solidity",
  "sources": {
    "src/contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\ninterface IDepositContract {\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n}\n"
    },
    "src/contracts/StakingContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\nimport \"./libs/StateLib.sol\";\nimport \"./libs/UintLib.sol\";\nimport \"./libs/BytesLib.sol\";\n\nimport \"./interfaces/IDepositContract.sol\";\n\n/// @title Ethereum Staking Contract\n/// @author SkillZ\n/// @notice You can use this contract to store validator keys and have users fund them and trigger deposits.\ncontract StakingContract {\n    using StateLib for bytes32;\n\n    bytes32 internal constant ADMIN_SLOT =\n        /* keccak256(\"StakingContract.admin\") */\n        hex\"fbeda9bc03875013b12a1ec161efb8e5bf7e58e3cec96a1ea9efd3e264d26e64\";\n    bytes32 internal constant VERSION_SLOT =\n        /* keccak256(\"StakingContract.version\") */\n        hex\"d5c553085b8382c47128ae7612257fd5dc3b4fc4d3a108925604d3c8700c025b\";\n    bytes32 internal constant OPERATOR_SLOT =\n        /* keccak256(\"StakingContract.operator\") */\n        hex\"dfe7334ae89a4aa54c085540947bfa7e13e6b6933be4c49f359d18e88c0dbde5\";\n    bytes32 internal constant SIGNATURES_SLOT =\n        /* keccak256(\"StakingContract.signatures\") */\n        hex\"2805e4a7c8c139ac2ebe63141d90c488245fd479906b2c60bd42603b8a2ca08b\";\n    bytes32 internal constant PUBLIC_KEYS_SLOT =\n        /* keccak256(\"StakingContract.publicKeys\") */\n        hex\"cc0b8384259c4a4e6418cdc72955757e9214822019f44d8b5283077c1b46d43c\";\n    bytes32 internal constant WITHDRAWERS_SLOT =\n        /* keccak256(\"StakingContract.withdrawers\") */\n        hex\"86647fdbbdb534026d3e0f93a551cecf651c2b40fcdfef4b9fd9ed826133e265\";\n    bytes32 internal constant VALIDATORS_COUNT_SLOT =\n        /* keccak256(\"StakingContract.validatorsCount\") */\n        hex\"e9622dd0bba60226e1dbc661ca8aae56cc90dc7e9b3f33ece002f6764b3801b8\";\n    bytes32 internal constant DEPOSIT_CONTRACT_SLOT =\n        /* keccak256(\"StakingContract.depositContract\") */\n        hex\"bc8b9852d17d50256bb221fdf6ee12d78dd493d807e907f7d223c40d65abd6b9\";\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        /* keccak256(\"StakingContract.withdrawalCredentials\") */\n        hex\"2783da738595cd6ebaec6fd0f06d62f2266a9e475e2d1feb1d26aa2d1e051255\";\n\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    error InvalidCall();\n    error Unauthorized();\n    error NotEnoughKeys();\n    error DepositFailure();\n    error InvalidArgument();\n    error UnsortedIndexes();\n    error InvalidPublicKeys();\n    error InvalidSignatures();\n    error AlreadyInitialized();\n    error InvalidMessageValue();\n    error FundedValidatorDeletionAttempt();\n\n    event Deposit(address indexed caller, address indexed withdrawer, bytes publicKey, bytes32 publicKeyRoot);\n\n    /// @notice Ensures an initialisation call has been called only once per _version value\n    /// @param _version The current initialisation value\n    modifier init(uint256 _version) {\n        if (_version != VERSION_SLOT.getUint256() + 1) {\n            revert AlreadyInitialized();\n        }\n\n        VERSION_SLOT.setUint256(_version);\n\n        _;\n    }\n\n    /// @notice Ensures that the caller is the operator\n    modifier onlyOperator() {\n        if (msg.sender != OPERATOR_SLOT.getAddress()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Ensures that the caller is the admin\n    modifier onlyAdmin() {\n        if (msg.sender != ADMIN_SLOT.getAddress()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Ensures that the caller is the operator or the admin\n    modifier onlyAdminOrOperator() {\n        if (msg.sender != ADMIN_SLOT.getAddress() && msg.sender != OPERATOR_SLOT.getAddress()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Initializes version 1 of Staking Contract\n    /// @param _operator Address of the operator allowed to add/remove keys\n    /// @param _admin Address of the admin allowed to change the operator and admin\n    /// @param _depositContract Address of the Deposit Contract\n    /// @param _withdrawalCredentials Withdrawal Credentials to apply to all provided keys upon deposit\n    function initialize_1(\n        address _operator,\n        address _admin,\n        address _depositContract,\n        bytes32 _withdrawalCredentials\n    ) external init(1) {\n        OPERATOR_SLOT.setAddress(_operator);\n        DEPOSIT_CONTRACT_SLOT.setAddress(_depositContract);\n        WITHDRAWAL_CREDENTIALS_SLOT.setBytes32(_withdrawalCredentials);\n        ADMIN_SLOT.setAddress(_admin);\n    }\n\n    /// @notice Retrieve the admin address\n    function getAdmin() external view returns (address) {\n        return ADMIN_SLOT.getAddress();\n    }\n\n    /// @notice Retrieve the operator address\n    function getOperator() external view returns (address) {\n        return OPERATOR_SLOT.getAddress();\n    }\n\n    /// @notice Retrieve the withdrawer for a specific public key\n    /// @param _publicKey Public Key to retrieve the withdrawer\n    function getWithdrawer(bytes memory _publicKey) external view returns (address) {\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        StateLib.Bytes32ToAddressMappingSlot storage publicKeyOwnership = WITHDRAWERS_SLOT\n            .getStorageBytes32ToAddressMapping();\n        return publicKeyOwnership.value[pubkeyRoot];\n    }\n\n    /// @notice Retrieve the amount of funded validators\n    function fundedValidatorsCount() external view returns (uint256) {\n        return VALIDATORS_COUNT_SLOT.getUint256();\n    }\n\n    /// @notice Retrieve the amount of registered validators (funded + not yet funded)\n    function totalValidatorCount() external view returns (uint256) {\n        return PUBLIC_KEYS_SLOT.getStorageBytesArray().value.length;\n    }\n\n    /// @notice Retrieve the details of a validator\n    /// @param _idx Index of the validator\n    function getValidator(uint256 _idx)\n        external\n        view\n        returns (\n            bytes memory publicKey,\n            bytes memory signature,\n            address withdrawer,\n            bool funded\n        )\n    {\n        StateLib.BytesArraySlot storage publicKeysStore = PUBLIC_KEYS_SLOT.getStorageBytesArray();\n        StateLib.BytesArraySlot storage signaturesStore = SIGNATURES_SLOT.getStorageBytesArray();\n        StateLib.Bytes32ToAddressMappingSlot storage withdrawers = WITHDRAWERS_SLOT.getStorageBytes32ToAddressMapping();\n        uint256 validatorCount = VALIDATORS_COUNT_SLOT.getUint256();\n\n        publicKey = publicKeysStore.value[_idx];\n        signature = signaturesStore.value[_idx];\n        withdrawer = withdrawers.value[sha256(BytesLib.pad64(publicKey))];\n        funded = _idx < validatorCount;\n    }\n\n    /// @notice Change the admin address\n    /// @dev Only the admin is allowed to call this method\n    /// @param _newAdmin New Admin address\n    function setAdmin(address _newAdmin) external onlyAdmin {\n        ADMIN_SLOT.setAddress(_newAdmin);\n    }\n\n    /// @notice Change the operator address\n    /// @dev Only the admin or the operator are allowed to call this method\n    /// @param _newOperator New Operator address\n    function setOperator(address _newOperator) external onlyAdminOrOperator {\n        OPERATOR_SLOT.setAddress(_newOperator);\n    }\n\n    /// @notice Change the withdrawer for a specific public key\n    /// @dev Only the previous withdrawer of the public key can change the withdrawer\n    /// @param _publicKey The public key to change\n    /// @param _newWithdrawer The new withdrawer address\n    function setWithdrawer(bytes memory _publicKey, address _newWithdrawer) external {\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        StateLib.Bytes32ToAddressMappingSlot storage publicKeyOwnership = WITHDRAWERS_SLOT\n            .getStorageBytes32ToAddressMapping();\n\n        if (msg.sender != publicKeyOwnership.value[pubkeyRoot]) {\n            revert Unauthorized();\n        }\n\n        publicKeyOwnership.value[pubkeyRoot] = _newWithdrawer;\n    }\n\n    /// @notice Explicit deposit method\n    /// @dev A multiple of 32 ETH should be sent\n    /// @param _withdrawer The withdrawer address\n    function deposit(address _withdrawer) external payable {\n        _deposit(_withdrawer);\n    }\n\n    /// @notice Implicit deposit method\n    /// @dev A multiple of 32 ETH should be sent\n    /// @dev The withdrawer is set to the message sender address\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Fallback detection\n    /// @dev Fails on any call that fallbacks\n    fallback() external payable {\n        revert InvalidCall();\n    }\n\n    /// @notice Register new validators\n    /// @dev Only the operator or the admin are allowed to call this method\n    /// @dev publickKeys is the concatenation of keyCount public keys\n    /// @dev signatures is the concatenation of keyCount signatures\n    /// @param keyCount The expected number of keys from publicKeys and signatures\n    /// @param publicKeys Concatenated public keys\n    /// @param signatures Concatenated signatures\n    function registerValidators(\n        uint256 keyCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) external onlyAdminOrOperator {\n        if (keyCount == 0) {\n            revert InvalidArgument();\n        }\n\n        if (publicKeys.length % PUBLIC_KEY_LENGTH != 0 || publicKeys.length / PUBLIC_KEY_LENGTH != keyCount) {\n            revert InvalidPublicKeys();\n        }\n\n        if (signatures.length % SIGNATURE_LENGTH != 0 || signatures.length / SIGNATURE_LENGTH != keyCount) {\n            revert InvalidSignatures();\n        }\n\n        StateLib.BytesArraySlot storage publicKeysStore = PUBLIC_KEYS_SLOT.getStorageBytesArray();\n        StateLib.BytesArraySlot storage signaturesStore = SIGNATURES_SLOT.getStorageBytesArray();\n\n        for (uint256 i; i < keyCount; ) {\n            bytes memory publicKey = BytesLib.slice(publicKeys, i * PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH);\n            bytes memory signature = BytesLib.slice(signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n\n            publicKeysStore.value.push(publicKey);\n            signaturesStore.value.push(signature);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Remove validators\n    /// @dev Only the operator or the admin are allowed to call this method\n    /// @dev The indexes to delete should all be greater than the amount of funded validators\n    /// @dev The indexes to delete should be sorted in descending order or the method will fail\n    /// @param _indexes The indexes to delete\n    function removeValidators(uint256[] calldata _indexes) external onlyAdminOrOperator {\n        if (_indexes.length == 0) {\n            revert InvalidArgument();\n        }\n\n        uint256 validatorsCount = VALIDATORS_COUNT_SLOT.getUint256();\n        StateLib.BytesArraySlot storage publicKeysStore = PUBLIC_KEYS_SLOT.getStorageBytesArray();\n        StateLib.BytesArraySlot storage signaturesStore = SIGNATURES_SLOT.getStorageBytesArray();\n\n        for (uint256 i; i < _indexes.length; ) {\n            if (i > 0 && _indexes[i] >= _indexes[i - 1]) {\n                revert UnsortedIndexes();\n            }\n\n            if (_indexes[i] < validatorsCount) {\n                revert FundedValidatorDeletionAttempt();\n            }\n\n            if (_indexes[i] == publicKeysStore.value.length - 1) {\n                publicKeysStore.value.pop();\n                signaturesStore.value.pop();\n            } else {\n                publicKeysStore.value[_indexes[i]] = publicKeysStore.value[publicKeysStore.value.length - 1];\n                publicKeysStore.value.pop();\n                signaturesStore.value[_indexes[i]] = signaturesStore.value[signaturesStore.value.length - 1];\n                signaturesStore.value.pop();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal utility to deposit a public key, its signature and 32 ETH to the consensus layer\n    /// @param _publicKey The Public Key to deposit\n    /// @param _signature The Signature to deposit\n    /// @param _withdrawalCredentials The Withdrawal Credentials to deposit\n    function _depositValidator(\n        bytes memory _publicKey,\n        bytes memory _signature,\n        bytes32 _withdrawalCredentials\n    ) internal {\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(BytesLib.pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n            )\n        );\n\n        uint256 depositAmount = DEPOSIT_SIZE / 1000000000 wei;\n        assert(depositAmount * 1000000000 wei == DEPOSIT_SIZE);\n\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n                sha256(abi.encodePacked(Uint256Lib.toLittleEndian64(depositAmount), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - DEPOSIT_SIZE;\n\n        IDepositContract(DEPOSIT_CONTRACT_SLOT.getAddress()).deposit{value: DEPOSIT_SIZE}(\n            _publicKey,\n            abi.encodePacked(_withdrawalCredentials),\n            _signature,\n            depositDataRoot\n        );\n\n        if (address(this).balance != targetBalance) {\n            revert DepositFailure();\n        }\n    }\n\n    /// @notice Perform one or multiple deposits for the same withdrawer\n    /// @param _withdrawer Address allowed to withdraw the funds of the deposits\n    function _deposit(address _withdrawer) internal {\n        if (msg.value == 0 || msg.value % DEPOSIT_SIZE != 0) {\n            revert InvalidMessageValue();\n        }\n\n        uint256 depositCount = msg.value / DEPOSIT_SIZE;\n        uint256 validatorCount = VALIDATORS_COUNT_SLOT.getUint256();\n        StateLib.BytesArraySlot storage publicKeysStore = PUBLIC_KEYS_SLOT.getStorageBytesArray();\n        StateLib.BytesArraySlot storage signaturesStore = SIGNATURES_SLOT.getStorageBytesArray();\n        bytes32 withdrawalCredentials = WITHDRAWAL_CREDENTIALS_SLOT.getBytes32();\n\n        if (validatorCount + depositCount > publicKeysStore.value.length) {\n            revert NotEnoughKeys();\n        }\n\n        StateLib.Bytes32ToAddressMappingSlot storage publicKeyOwnership = WITHDRAWERS_SLOT\n            .getStorageBytes32ToAddressMapping();\n\n        for (uint256 i; i < depositCount; ) {\n            bytes memory publicKey = publicKeysStore.value[validatorCount + i];\n            bytes32 publicKeyRoot = sha256(BytesLib.pad64(publicKey));\n            _depositValidator(publicKey, signaturesStore.value[validatorCount + i], withdrawalCredentials);\n            publicKeyOwnership.value[publicKeyRoot] = _withdrawer;\n            emit Deposit(msg.sender, _withdrawer, publicKey, publicKeyRoot);\n            unchecked {\n                ++i;\n            }\n        }\n\n        VALIDATORS_COUNT_SLOT.setUint256(validatorCount + depositCount);\n    }\n}\n"
    },
    "src/contracts/libs/StateLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary StateLib {\n    function getUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setUint256(bytes32 position, uint256 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getAddress(bytes32 position) internal view returns (address data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setAddress(bytes32 position, address data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setBytes32(bytes32 position, bytes32 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    struct Bytes32ToAddressMappingSlot {\n        mapping(bytes32 => address) value;\n    }\n\n    function getStorageBytes32ToAddressMapping(bytes32 position)\n        internal\n        pure\n        returns (Bytes32ToAddressMappingSlot storage r)\n    {\n        assembly {\n            r.slot := position\n        }\n    }\n\n    struct BytesArraySlot {\n        bytes[] value;\n    }\n\n    function getStorageBytesArray(bytes32 position) internal pure returns (BytesArraySlot storage r) {\n        assembly {\n            r.slot := position\n        }\n    }\n}\n"
    },
    "src/contracts/libs/UintLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary Uint256Lib {\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 temp_value = _value;\n        for (uint256 i = 0; i < 8; ++i) {\n            result = (result << 8) | (temp_value & 0xFF);\n            temp_value >>= 8;\n        }\n\n        assert(0 == temp_value); // fully converted\n        result <<= (24 * 8);\n    }\n}\n"
    },
    "src/contracts/libs/BytesLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary BytesLib {\n    function pad64(bytes memory _b) internal pure returns (bytes memory) {\n        assert(_b.length >= 32 && _b.length <= 64);\n        if (64 == _b.length) return _b;\n\n        bytes memory zero32 = new bytes(32);\n        assembly {\n            mstore(add(zero32, 0x20), 0)\n        }\n\n        if (32 == _b.length) return BytesLib.concat(_b, zero32);\n        else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64) - _b.length));\n    }\n\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "src/contracts/TUPProxy.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/// @title TUPProxy (Transparent Upgradeable Pausable Proxy)\n/// @author SkillZ\n/// @notice This contract extends the Transparent Upgradeable proxy and adds a system wide pause feature.\n///         When the system is paused, the fallback will fail no matter what calls are made.\ncontract TUPProxy is TransparentUpgradeableProxy {\n    bytes32 private constant _PAUSE_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.pause\")) - 1);\n\n    error CallWhenPaused();\n\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n    /// @dev Retrieves Paused state\n    /// @return Paused state\n    function isPaused() external ifAdmin returns (bool) {\n        return StorageSlot.getBooleanSlot(_PAUSE_SLOT).value;\n    }\n\n    /// @dev Pauses system\n    function pause() external ifAdmin {\n        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = true;\n    }\n\n    /// @dev Unpauses system\n    function unpause() external ifAdmin {\n        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = false;\n    }\n\n    /// @dev Overrides the fallback method to check if system is not paused before\n    /// @dev Address Zero is allowed to perform calls even if system is paused. This allows\n    /// view functions to be called when the system is paused as rpc providers can easily\n    /// set the sender address to zero.\n    function _beforeFallback() internal override {\n        if (StorageSlot.getBooleanSlot(_PAUSE_SLOT).value == false || msg.sender == address(0)) {\n            super._beforeFallback();\n        } else {\n            revert CallWhenPaused();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "src/contracts/WithdrawContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\n/// @title Ethereum Withdraw Contract\n/// @author SkillZ\n/// @notice This upgradeable contract will be in charge of handling the withdrawals\n///         coming from the consensus layer\ncontract WithdrawContract {\n    /// @notice Retrieve the bytes32 encoded withdrawal credentials to use for the deposits\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return\n            bytes32(\n                uint256(uint160(address(this))) + 0x0100000000000000000000000000000000000000000000000000000000000000\n            );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}