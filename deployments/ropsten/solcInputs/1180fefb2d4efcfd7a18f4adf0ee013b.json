{
  "language": "Solidity",
  "sources": {
    "src/contracts/ConsensusLayerFeeRecipient.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\nimport \"./libs/FeeRecipientStorageLib.sol\";\nimport \"./interfaces/IStakingContractFeeDetails.sol\";\n\n/// @title Consensus Layer Fee Recipient\n/// @author Kiln\n/// @notice This contract can be used to receive fees from a validator and split them with a node operator\ncontract ConsensusLayerFeeRecipient {\n    using FeeRecipientStorageLib for bytes32;\n\n    event Withdrawal(address indexed withdrawer, address indexed feeRecipient, uint256 rewards, uint256 fee);\n\n    error FeeRecipientReceiveError(bytes errorData);\n    error WithdrawerReceiveError(bytes errorData);\n    error ZeroBalanceWithdrawal();\n    error AlreadyInitialized();\n    error InvalidCall();\n\n    bytes32 internal constant STAKING_CONTRACT_ADDRESS_SLOT =\n        keccak256(\"ConsensusLayerFeeRecipient.stakingContractAddress\");\n    bytes32 internal constant VALIDATOR_PUBLIC_KEY_SLOT = keccak256(\"ConsensusLayerFeeRecipient.validatorPublicKey\");\n    uint256 internal constant BASIS_POINTS = 10_000;\n    bytes32 internal constant VERSION_SLOT = keccak256(\"ConsensusLayerFeeRecipient.version\");\n\n    /// @notice Ensures an initialisation call has been called only once per _version value\n    /// @param _version The current initialisation value\n    modifier init(uint256 _version) {\n        if (_version != VERSION_SLOT.getUint256() + 1) {\n            revert AlreadyInitialized();\n        }\n\n        VERSION_SLOT.setUint256(_version);\n\n        _;\n    }\n\n    /// @notice Constructor method allowing us to prevent calls to initCLFR by setting the appropriate version\n    constructor(uint256 _version) {\n        VERSION_SLOT.setUint256(_version);\n    }\n\n    /// @notice Initialize the contract by storing the staking contract and the public key in storage\n    /// @param _stakingContract Address of the Staking Contract\n    /// @param _publicKeyRoot Hash of the public key linked to this fee recipient\n    function initCLFR(address _stakingContract, bytes32 _publicKeyRoot) external init(1) {\n        STAKING_CONTRACT_ADDRESS_SLOT.setAddress(_stakingContract);\n        VALIDATOR_PUBLIC_KEY_SLOT.setBytes32(_publicKeyRoot);\n    }\n\n    /// @notice Performs a withdrawal on this contract's balance\n    function withdraw() external {\n        uint256 balance = address(this).balance;\n        if (balance == 0) {\n            revert ZeroBalanceWithdrawal();\n        }\n        IStakingContractFeeDetails stakingContract = IStakingContractFeeDetails(\n            STAKING_CONTRACT_ADDRESS_SLOT.getAddress()\n        );\n        bytes32 pubKeyRoot = VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n        address withdrawer = stakingContract.getWithdrawerFromPublicKeyRoot(pubKeyRoot);\n        uint256 feeBps = stakingContract.getCLFee();\n        address feeRecipient = stakingContract.getOperatorFeeRecipient(pubKeyRoot);\n\n        uint256 fee;\n        if (balance >= 32 ether) {\n            // withdrawing a healthy & exited validator\n            fee = ((balance - 32 ether) * feeBps) / BASIS_POINTS;\n        } else if (balance <= 16 ether) {\n            // withdrawing from what looks like skimming\n            fee = (balance * feeBps) / BASIS_POINTS;\n        } else {\n            // withdrawing from slashed validator (< 32 eth and > 16 eth)\n            fee = 0;\n        }\n\n        (bool status, bytes memory data) = withdrawer.call{value: balance - fee}(\"\");\n        if (status == false) {\n            revert WithdrawerReceiveError(data);\n        }\n        if (fee > 0) {\n            (status, data) = feeRecipient.call{value: fee}(\"\");\n            if (status == false) {\n                revert FeeRecipientReceiveError(data);\n            }\n        }\n        emit Withdrawal(withdrawer, feeRecipient, balance - fee, fee);\n    }\n\n    /// @notice Retrieve the staking contract address\n    function getStakingContract() external view returns (address) {\n        return STAKING_CONTRACT_ADDRESS_SLOT.getAddress();\n    }\n\n    /// @notice Retrieve the assigned withdrawer\n    function getWithdrawer() external view returns (address) {\n        IStakingContractFeeDetails stakingContract = IStakingContractFeeDetails(\n            STAKING_CONTRACT_ADDRESS_SLOT.getAddress()\n        );\n        bytes32 pubKeyRoot = VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n        address withdrawer = stakingContract.getWithdrawerFromPublicKeyRoot(pubKeyRoot);\n        return withdrawer;\n    }\n\n    /// @notice Retrieve the assigned public key root\n    function getPublicKeyRoot() external view returns (bytes32) {\n        return VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {\n        revert InvalidCall();\n    }\n}\n"
    },
    "src/contracts/libs/FeeRecipientStorageLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary FeeRecipientStorageLib {\n    function getUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setUint256(bytes32 position, uint256 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getAddress(bytes32 position) internal view returns (address data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setAddress(bytes32 position, address data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setBytes32(bytes32 position, bytes32 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n}\n"
    },
    "src/contracts/interfaces/IStakingContractFeeDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\ninterface IStakingContractFeeDetails {\n    function getWithdrawerFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (address);\n\n    function getELFee() external view returns (uint256);\n\n    function getCLFee() external view returns (uint256);\n\n    function getOperatorFeeRecipient(bytes32 pubKeyRoot) external view returns (address);\n}\n"
    },
    "src/contracts/ExecutionLayerFeeRecipient.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\nimport \"./libs/FeeRecipientStorageLib.sol\";\nimport \"./interfaces/IStakingContractFeeDetails.sol\";\n\n/// @title Execution Layer Fee Recipient\n/// @author Kiln\n/// @notice This contract can be used to receive fees from a validator and split them with a node operator\ncontract ExecutionLayerFeeRecipient {\n    using FeeRecipientStorageLib for bytes32;\n\n    event Withdrawal(address indexed withdrawer, address indexed feeRecipient, uint256 rewards, uint256 fee);\n\n    error FeeRecipientReceiveError(bytes errorData);\n    error WithdrawerReceiveError(bytes errorData);\n    error ZeroBalanceWithdrawal();\n    error AlreadyInitialized();\n    error InvalidCall();\n\n    bytes32 internal constant STAKING_CONTRACT_ADDRESS_SLOT =\n        keccak256(\"ExecutionLayerFeeRecipient.stakingContractAddress\");\n    bytes32 internal constant VALIDATOR_PUBLIC_KEY_SLOT = keccak256(\"ExecutionLayerFeeRecipient.validatorPublicKey\");\n    uint256 internal constant BASIS_POINTS = 10_000;\n    bytes32 internal constant VERSION_SLOT = keccak256(\"ExecutionLayerFeeRecipient.version\");\n\n    /// @notice Ensures an initialisation call has been called only once per _version value\n    /// @param _version The current initialisation value\n    modifier init(uint256 _version) {\n        if (_version != VERSION_SLOT.getUint256() + 1) {\n            revert AlreadyInitialized();\n        }\n\n        VERSION_SLOT.setUint256(_version);\n\n        _;\n    }\n\n    /// @notice Constructor method allowing us to prevent calls to initCLFR by setting the appropriate version\n    constructor(uint256 _version) {\n        VERSION_SLOT.setUint256(_version);\n    }\n\n    /// @notice Initialize the contract by storing the staking contract and the public key in storage\n    /// @param _stakingContract Address of the Staking Contract\n    /// @param _publicKeyRoot Hash of the public key linked to this fee recipient\n    function initELFR(address _stakingContract, bytes32 _publicKeyRoot) external init(1) {\n        STAKING_CONTRACT_ADDRESS_SLOT.setAddress(_stakingContract);\n        VALIDATOR_PUBLIC_KEY_SLOT.setBytes32(_publicKeyRoot);\n    }\n\n    /// @notice Performs a withdrawal on this contract's balance\n    function withdraw() external {\n        uint256 balance = address(this).balance;\n        if (balance == 0) {\n            revert ZeroBalanceWithdrawal();\n        }\n        IStakingContractFeeDetails stakingContract = IStakingContractFeeDetails(\n            STAKING_CONTRACT_ADDRESS_SLOT.getAddress()\n        );\n        bytes32 pubKeyRoot = VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n        address withdrawer = stakingContract.getWithdrawerFromPublicKeyRoot(pubKeyRoot);\n        uint256 feeBps = stakingContract.getELFee();\n        address feeRecipient = stakingContract.getOperatorFeeRecipient(pubKeyRoot);\n        uint256 fee = (balance * feeBps) / BASIS_POINTS;\n        (bool status, bytes memory data) = withdrawer.call{value: balance - fee}(\"\");\n        if (status == false) {\n            revert WithdrawerReceiveError(data);\n        }\n        if (fee > 0) {\n            (status, data) = feeRecipient.call{value: fee}(\"\");\n            if (status == false) {\n                revert FeeRecipientReceiveError(data);\n            }\n        }\n        emit Withdrawal(withdrawer, feeRecipient, balance - fee, fee);\n    }\n\n    /// @notice Retrieve the staking contract address\n    function getStakingContract() external view returns (address) {\n        return STAKING_CONTRACT_ADDRESS_SLOT.getAddress();\n    }\n\n    /// @notice Retrieve the assigned withdrawer\n    function getWithdrawer() external view returns (address) {\n        IStakingContractFeeDetails stakingContract = IStakingContractFeeDetails(\n            STAKING_CONTRACT_ADDRESS_SLOT.getAddress()\n        );\n        bytes32 pubKeyRoot = VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n        address withdrawer = stakingContract.getWithdrawerFromPublicKeyRoot(pubKeyRoot);\n        return withdrawer;\n    }\n\n    /// @notice Retrieve the assigned public key root\n    function getPublicKeyRoot() external view returns (bytes32) {\n        return VALIDATOR_PUBLIC_KEY_SLOT.getBytes32();\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {\n        revert InvalidCall();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}