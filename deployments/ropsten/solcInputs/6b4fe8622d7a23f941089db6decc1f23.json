{
  "language": "Solidity",
  "sources": {
    "src/contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\ninterface IDepositContract {\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n}\n"
    },
    "src/contracts/StakingContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\nimport \"./libs/UintLib.sol\";\nimport \"./libs/BytesLib.sol\";\nimport \"./interfaces/IFeeRecipient.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./libs/StakingContractStorageLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title Ethereum Staking Contract\n/// @author Kiln\n/// @notice You can use this contract to store validator keys and have users fund them and trigger deposits.\ncontract StakingContract {\n    using StakingContractStorageLib for bytes32;\n\n    uint256 internal constant EXECUTION_LAYER_SALT_PREFIX = 0;\n    uint256 internal constant CONSENSUS_LAYER_SALT_PREFIX = 1;\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n    uint256 internal constant BASIS_POINTS = 10_000;\n\n    error Deactivated();\n    error NoOperators();\n    error InvalidCall();\n    error Unauthorized();\n    error InvalidFee();\n    error NotEnoughKeys();\n    error DepositFailure();\n    error InvalidArgument();\n    error UnsortedIndexes();\n    error InvalidPublicKeys();\n    error InvalidSignatures();\n    error AlreadyInitialized();\n    error InvalidDepositValue();\n    error NotEnoughValidators();\n    error InvalidValidatorCount();\n    error DuplicateValidatorKey(bytes);\n    error FundedValidatorDeletionAttempt();\n    error OperatorLimitTooHigh(uint256 limit, uint256 keyCount);\n\n    struct ValidatorAllocationCache {\n        bool used;\n        uint8 operatorIndex;\n        uint32 funded;\n        uint32 toDeposit;\n        uint32 available;\n    }\n\n    event Deposit(address indexed caller, address indexed withdrawer, bytes publicKey);\n    event ValidatorKeysAdded(uint256 indexed operatorIndex, bytes publicKeys);\n    event ValidatorKeyRemoved(uint256 indexed operatorIndex, bytes publicKey);\n\n    /// @notice Ensures an initialisation call has been called only once per _version value\n    /// @param _version The current initialisation value\n    modifier init(uint256 _version) {\n        if (_version != StakingContractStorageLib.getVersion() + 1) {\n            revert AlreadyInitialized();\n        }\n\n        StakingContractStorageLib.setVersion(_version);\n        _;\n    }\n\n    /// @notice Ensures that the caller is the admin\n    modifier onlyAdmin() {\n        if (msg.sender != StakingContractStorageLib.getAdmin()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Ensures that the caller is the admin or the operator\n    modifier onlyActiveOperatorOrAdmin(uint256 _operatorIndex) {\n        if (msg.sender == StakingContractStorageLib.getAdmin()) {\n            _;\n        } else {\n            _onlyActiveOperator(_operatorIndex);\n            _;\n        }\n    }\n\n    /// @notice Ensures that the caller is the admin\n    modifier onlyActiveOperator(uint256 _operatorIndex) {\n        _onlyActiveOperator(_operatorIndex);\n        _;\n    }\n\n    /// @notice Ensures that the caller is the operator fee recipient\n    modifier onlyOperatorFeeRecipient(uint256 _operatorIndex) {\n        StakingContractStorageLib.OperatorInfo memory operatorInfo = StakingContractStorageLib.getOperators().value[\n            _operatorIndex\n        ];\n\n        if (operatorInfo.deactivated) {\n            revert Deactivated();\n        }\n\n        if (msg.sender != operatorInfo.feeRecipient) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Explicit deposit method\n    /// @dev A multiple of 32 ETH should be sent\n    /// @param _withdrawer The withdrawer address\n    function deposit(address _withdrawer) external payable {\n        _deposit(_withdrawer);\n    }\n\n    /// @notice Explicit deposit method using msg.sender\n    /// @dev A multiple of 32 ETH should be sent\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Implicit deposit method\n    /// @dev A multiple of 32 ETH should be sent\n    /// @dev The withdrawer is set to the message sender address\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Fallback detection\n    /// @dev Fails on any call that fallbacks\n    fallback() external payable {\n        revert InvalidCall();\n    }\n\n    function initialize_1(\n        address _admin,\n        address _treasury,\n        address _depositContract,\n        address _elDispatcher,\n        address _clDispatcher,\n        address _feeRecipientImplementation,\n        uint256 _globalFee,\n        uint256 _operatorFee\n    ) external init(1) {\n        StakingContractStorageLib.setAdmin(_admin);\n        StakingContractStorageLib.setTreasury(_treasury);\n        StakingContractStorageLib.setGlobalFee(_globalFee);\n        StakingContractStorageLib.setOperatorFee(_operatorFee);\n        StakingContractStorageLib.setELDispatcher(_elDispatcher);\n        StakingContractStorageLib.setCLDispatcher(_clDispatcher);\n        StakingContractStorageLib.setDepositContract(_depositContract);\n        StakingContractStorageLib.setFeeRecipientImplementation(_feeRecipientImplementation);\n    }\n\n    /// @notice Retrieve system admin\n    function getAdmin() external view returns (address) {\n        return StakingContractStorageLib.getAdmin();\n    }\n\n    /// @notice Retrieve system treasury\n    function getTreasury() external view returns (address) {\n        return StakingContractStorageLib.getTreasury();\n    }\n\n    /// @notice Retrieve the global fee\n    function getGlobalFee() external view returns (uint256) {\n        return StakingContractStorageLib.getGlobalFee();\n    }\n\n    /// @notice Retrieve the operator fee\n    function getOperatorFee() external view returns (uint256) {\n        return StakingContractStorageLib.getOperatorFee();\n    }\n\n    /// @notice Compute the Execution Layer Fee recipient address for a given validator public key\n    /// @param _publicKey Validator to get the recipient\n    function getELFeeRecipient(bytes calldata _publicKey) external view returns (address) {\n        return _getDeterministicReceiver(_publicKey, EXECUTION_LAYER_SALT_PREFIX);\n    }\n\n    /// @notice Compute the Consensus Layer Fee recipient address for a given validator public key\n    /// @param _publicKey Validator to get the recipient\n    function getCLFeeRecipient(bytes calldata _publicKey) external view returns (address) {\n        return _getDeterministicReceiver(_publicKey, CONSENSUS_LAYER_SALT_PREFIX);\n    }\n\n    /// @notice Retrieve the Execution & Consensus Layer Fee operator recipient for a given public key\n    function getOperatorFeeRecipient(bytes32 pubKeyRoot) external view returns (address) {\n        return\n            StakingContractStorageLib\n                .getOperators()\n                .value[StakingContractStorageLib.getOperatorIndexPerValidator().value[pubKeyRoot].operatorIndex]\n                .feeRecipient;\n    }\n\n    /// @notice Retrieve withdrawer of public key\n    /// @param _publicKey Public Key to check\n    function getWithdrawer(bytes calldata _publicKey) external view returns (address) {\n        return _getWithdrawer(_getPubKeyRoot(_publicKey));\n    }\n\n    /// @notice Retrieve withdrawer of public key root\n    /// @param _publicKeyRoot Hash of the public key\n    function getWithdrawerFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (address) {\n        return _getWithdrawer(_publicKeyRoot);\n    }\n\n    /// @notice Retrieve operator details\n    /// @param _operatorIndex Operator index\n    function getOperator(uint256 _operatorIndex)\n        external\n        view\n        returns (\n            address operatorAddress,\n            address feeRecipientAddress,\n            uint256 limit,\n            uint256 keys,\n            uint256 funded,\n            uint256 available,\n            bool deactivated\n        )\n    {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        if (_operatorIndex < operators.value.length) {\n            StakingContractStorageLib.ValidatorsFundingInfo memory _operatorInfo = StakingContractStorageLib\n                .getValidatorsFundingInfo(_operatorIndex);\n            StakingContractStorageLib.OperatorInfo memory _operator = operators.value[_operatorIndex];\n\n            (operatorAddress, feeRecipientAddress, limit, keys, deactivated) = (\n                _operator.operator,\n                _operator.feeRecipient,\n                _operator.limit,\n                _operator.publicKeys.length,\n                _operator.deactivated\n            );\n            (funded, available) = (_operatorInfo.funded, _operatorInfo.availableKeys);\n        }\n    }\n\n    /// @notice Get details about a validator\n    /// @param _operatorIndex Index of the operator running the validator\n    /// @param _validatorIndex Index of the validator\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (\n            bytes memory publicKey,\n            bytes memory signature,\n            address withdrawer,\n            bool funded\n        )\n    {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        publicKey = operators.value[_operatorIndex].publicKeys[_validatorIndex];\n        signature = operators.value[_operatorIndex].signatures[_validatorIndex];\n        withdrawer = _getWithdrawer(_getPubKeyRoot(publicKey));\n        funded = _validatorIndex < StakingContractStorageLib.getValidatorsFundingInfo(_operatorIndex).funded;\n    }\n\n    /// @notice Get the total available keys that are ready to be used for deposits\n    function getAvailableValidatorCount() external view returns (uint256) {\n        return StakingContractStorageLib.getTotalAvailableValidators();\n    }\n\n    /// @notice Set new admin\n    /// @dev Only callable by admin\n    /// @param _newAdmin New Administrator address\n    function setAdmin(address _newAdmin) external onlyAdmin {\n        StakingContractStorageLib.setAdmin(_newAdmin);\n    }\n\n    /// @notice Add new operator\n    /// @dev Only callable by admin\n    /// @param _operatorAddress Operator address allowed to add / remove validators\n    /// @param _feeRecipientAddress Operator address used to manage rewards\n    function addOperator(address _operatorAddress, address _feeRecipientAddress) external onlyAdmin returns (uint256) {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        StakingContractStorageLib.OperatorInfo memory newOperator;\n        newOperator.operator = _operatorAddress;\n        newOperator.feeRecipient = _feeRecipientAddress;\n        operators.value.push(newOperator);\n        return operators.value.length - 1;\n    }\n\n    /// @notice Set new operator addresses (operations and reward management)\n    /// @dev Only callable by fee recipient address manager\n    /// @param _operatorIndex Index of the operator to update\n    /// @param _operatorAddress New operator address for operations management\n    /// @param _feeRecipientAddress New operator address for reward management\n    function setOperatorAddresses(\n        uint256 _operatorIndex,\n        address _operatorAddress,\n        address _feeRecipientAddress\n    ) external onlyOperatorFeeRecipient(_operatorIndex) {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n\n        operators.value[_operatorIndex].operator = _operatorAddress;\n        operators.value[_operatorIndex].feeRecipient = _feeRecipientAddress;\n    }\n\n    /// @notice Set withdrawer for public key\n    /// @dev Only callable by current public key withdrawer\n    /// @param _publicKey Public key to change withdrawer\n    /// @param _newWithdrawer New withdrawer address\n    function setWithdrawer(bytes calldata _publicKey, address _newWithdrawer) external {\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        StakingContractStorageLib.WithdrawersSlot storage withdrawers = StakingContractStorageLib.getWithdrawers();\n\n        if (withdrawers.value[pubkeyRoot] != msg.sender) {\n            revert Unauthorized();\n        }\n\n        withdrawers.value[pubkeyRoot] = _newWithdrawer;\n    }\n\n    /// @notice Set operator staking limits\n    /// @dev Only callable by admin\n    /// @dev Limit should not exceed the validator key count of the operator\n    /// @dev Keys should be registered before limit is increased\n    /// @dev Allows all keys to be verified by the system admin before limit is increased\n    /// @param _operatorIndex Operator Index\n    /// @param _limit New staking limit\n    function setOperatorLimit(uint256 _operatorIndex, uint256 _limit) external onlyAdmin {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        uint256 publicKeyCount = operators.value[_operatorIndex].publicKeys.length;\n        if (publicKeyCount < _limit) {\n            revert OperatorLimitTooHigh(_limit, publicKeyCount);\n        }\n        operators.value[_operatorIndex].limit = _limit;\n        _updateAvailableValidatorCount(_operatorIndex);\n    }\n\n    /// @notice Deactivates an operator and changes the fee recipient address and the staking limit\n    /// @param _operatorIndex Operator Index\n    /// @param _temporaryFeeRecipient Temporary address to receive funds decided by the system admin\n    function deactivateOperator(uint256 _operatorIndex, address _temporaryFeeRecipient) external onlyAdmin {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        operators.value[_operatorIndex].limit = 0;\n        operators.value[_operatorIndex].deactivated = true;\n        operators.value[_operatorIndex].feeRecipient = _temporaryFeeRecipient;\n        _updateAvailableValidatorCount(_operatorIndex);\n    }\n\n    /// @notice Activates an operator, without changing its 0 staking limit\n    /// @param _operatorIndex Operator Index\n    /// @param _newFeeRecipient Sets the fee recipient address\n    function activateOperator(uint256 _operatorIndex, address _newFeeRecipient) external onlyAdmin {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        operators.value[_operatorIndex].deactivated = false;\n        operators.value[_operatorIndex].feeRecipient = _newFeeRecipient;\n    }\n\n    /// @notice Change the Operator fee\n    /// @param _operatorFee Fee in Basis Point\n    function setOperatorFee(uint256 _operatorFee) external onlyAdmin {\n        if (_operatorFee > BASIS_POINTS) {\n            revert InvalidFee();\n        }\n        StakingContractStorageLib.setOperatorFee(_operatorFee);\n    }\n\n    /// @notice Change the Global fee\n    /// @param _globalFee Fee in Basis Point\n    function setGlobalFee(uint256 _globalFee) external onlyAdmin {\n        if (_globalFee > BASIS_POINTS) {\n            revert InvalidFee();\n        }\n        StakingContractStorageLib.setGlobalFee(_globalFee);\n    }\n\n    /// @notice Add new validator public keys and signatures\n    /// @dev Only callable by operator\n    /// @param _operatorIndex Operator Index\n    /// @param _keyCount Number of keys added\n    /// @param _publicKeys Concatenated _keyCount public keys\n    /// @param _signatures Concatenated _keyCount signatures\n    function addValidators(\n        uint256 _operatorIndex,\n        uint256 _keyCount,\n        bytes calldata _publicKeys,\n        bytes calldata _signatures\n    ) external onlyActiveOperator(_operatorIndex) {\n        if (_keyCount == 0) {\n            revert InvalidArgument();\n        }\n\n        if (_publicKeys.length % PUBLIC_KEY_LENGTH != 0 || _publicKeys.length / PUBLIC_KEY_LENGTH != _keyCount) {\n            revert InvalidPublicKeys();\n        }\n\n        if (_signatures.length % SIGNATURE_LENGTH != 0 || _signatures.length / SIGNATURE_LENGTH != _keyCount) {\n            revert InvalidSignatures();\n        }\n\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        StakingContractStorageLib.OperatorIndexPerValidatorSlot\n            storage operatorIndexPerValidator = StakingContractStorageLib.getOperatorIndexPerValidator();\n\n        for (uint256 i; i < _keyCount; ) {\n            bytes memory publicKey = BytesLib.slice(_publicKeys, i * PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH);\n            bytes memory signature = BytesLib.slice(_signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n\n            operators.value[_operatorIndex].publicKeys.push(publicKey);\n            operators.value[_operatorIndex].signatures.push(signature);\n\n            bytes32 pubKeyRoot = _getPubKeyRoot(publicKey);\n\n            if (operatorIndexPerValidator.value[pubKeyRoot].enabled) {\n                revert DuplicateValidatorKey(publicKey);\n            }\n\n            operatorIndexPerValidator.value[pubKeyRoot] = StakingContractStorageLib.OperatorIndex({\n                enabled: true,\n                operatorIndex: uint32(_operatorIndex)\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ValidatorKeysAdded(_operatorIndex, _publicKeys);\n\n        _updateAvailableValidatorCount(_operatorIndex);\n    }\n\n    /// @notice Remove unfunded validators\n    /// @dev Only callable by operator\n    /// @dev Indexes should be provided in decreasing order\n    /// @dev The limit will be set to the lowest removed operator index to ensure all changes above the\n    ///      lowest removed validator key are verified by the system administrator\n    /// @param _operatorIndex Operator Index\n    /// @param _indexes List of indexes to delete, in decreasing order\n    function removeValidators(uint256 _operatorIndex, uint256[] calldata _indexes)\n        external\n        onlyActiveOperatorOrAdmin(_operatorIndex)\n    {\n        if (_indexes.length == 0) {\n            revert InvalidArgument();\n        }\n\n        StakingContractStorageLib.ValidatorsFundingInfo memory operatorInfo = StakingContractStorageLib\n            .getValidatorsFundingInfo(_operatorIndex);\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n\n        if (_indexes[_indexes.length - 1] < operatorInfo.funded) {\n            revert FundedValidatorDeletionAttempt();\n        }\n        for (uint256 i; i < _indexes.length; ) {\n            if (i > 0 && _indexes[i] >= _indexes[i - 1]) {\n                revert UnsortedIndexes();\n            }\n\n            emit ValidatorKeyRemoved(_operatorIndex, operators.value[_operatorIndex].publicKeys[_indexes[i]]);\n            if (_indexes[i] == operators.value[_operatorIndex].publicKeys.length - 1) {\n                operators.value[_operatorIndex].publicKeys.pop();\n                operators.value[_operatorIndex].signatures.pop();\n            } else {\n                operators.value[_operatorIndex].publicKeys[_indexes[i]] = operators.value[_operatorIndex].publicKeys[\n                    operators.value[_operatorIndex].publicKeys.length - 1\n                ];\n                operators.value[_operatorIndex].publicKeys.pop();\n                operators.value[_operatorIndex].signatures[_indexes[i]] = operators.value[_operatorIndex].signatures[\n                    operators.value[_operatorIndex].signatures.length - 1\n                ];\n                operators.value[_operatorIndex].signatures.pop();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_indexes[_indexes.length - 1] < operators.value[_operatorIndex].limit) {\n            operators.value[_operatorIndex].limit = _indexes[_indexes.length - 1];\n        }\n\n        _updateAvailableValidatorCount(_operatorIndex);\n    }\n\n    /// @notice Withdraw the Execution Layer Fee for a given validator public key\n    /// @dev Funds are sent to the withdrawer account\n    /// @dev This method is public on purpose\n    /// @param _publicKey Validator to withdraw Execution Layer Fees from\n    function withdrawELFee(bytes calldata _publicKey) external {\n        _deployAndWithdraw(_publicKey, EXECUTION_LAYER_SALT_PREFIX, StakingContractStorageLib.getELDispatcher());\n    }\n\n    /// @notice Withdraw the Consensus Layer Fee for a given validator public key\n    /// @dev Funds are sent to the withdrawer account\n    /// @dev This method is public on purpose\n    /// @param _publicKey Validator to withdraw Consensus Layer Fees from\n    function withdrawCLFee(bytes calldata _publicKey) external {\n        _deployAndWithdraw(_publicKey, CONSENSUS_LAYER_SALT_PREFIX, StakingContractStorageLib.getCLDispatcher());\n    }\n\n    /// @notice Withdraw both Consensus and Execution Layer Fee for a given validator public key\n    /// @dev Reverts if any is null\n    /// @param _publicKey Validator to withdraw Execution and Consensus Layer Fees from\n    function withdraw(bytes calldata _publicKey) external {\n        _deployAndWithdraw(_publicKey, EXECUTION_LAYER_SALT_PREFIX, StakingContractStorageLib.getELDispatcher());\n        _deployAndWithdraw(_publicKey, CONSENSUS_LAYER_SALT_PREFIX, StakingContractStorageLib.getCLDispatcher());\n    }\n\n    /// ██ ███    ██ ████████ ███████ ██████  ███    ██  █████  ██\n    /// ██ ████   ██    ██    ██      ██   ██ ████   ██ ██   ██ ██\n    /// ██ ██ ██  ██    ██    █████   ██████  ██ ██  ██ ███████ ██\n    /// ██ ██  ██ ██    ██    ██      ██   ██ ██  ██ ██ ██   ██ ██\n    /// ██ ██   ████    ██    ███████ ██   ██ ██   ████ ██   ██ ███████\n\n    function _onlyActiveOperator(uint256 _operatorIndex) internal view {\n        StakingContractStorageLib.OperatorInfo memory operatorInfo = StakingContractStorageLib.getOperators().value[\n            _operatorIndex\n        ];\n\n        if (operatorInfo.deactivated) {\n            revert Deactivated();\n        }\n\n        if (msg.sender != operatorInfo.operator) {\n            revert Unauthorized();\n        }\n    }\n\n    function _getPubKeyRoot(bytes memory _publicKey) internal pure returns (bytes32) {\n        return sha256(BytesLib.pad64(_publicKey));\n    }\n\n    function _getWithdrawer(bytes32 _publicKeyRoot) internal view returns (address) {\n        return StakingContractStorageLib.getWithdrawers().value[_publicKeyRoot];\n    }\n\n    function _updateAvailableValidatorCount(uint256 _operatorIndex) internal {\n        StakingContractStorageLib.ValidatorsFundingInfo memory validatorFundingInfo = StakingContractStorageLib\n            .getValidatorsFundingInfo(_operatorIndex);\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n\n        uint32 oldAvailableCount = validatorFundingInfo.availableKeys;\n        uint32 newAvailableCount = 0;\n        uint256 cap = _min(operators.value[_operatorIndex].limit, operators.value[_operatorIndex].publicKeys.length);\n\n        if (cap <= validatorFundingInfo.funded) {\n            StakingContractStorageLib.setValidatorsFundingInfo(_operatorIndex, 0, validatorFundingInfo.funded);\n        } else {\n            newAvailableCount = uint32(cap - validatorFundingInfo.funded);\n            StakingContractStorageLib.setValidatorsFundingInfo(\n                _operatorIndex,\n                newAvailableCount,\n                validatorFundingInfo.funded\n            );\n        }\n\n        if (oldAvailableCount != newAvailableCount) {\n            StakingContractStorageLib.setTotalAvailableValidators(\n                (StakingContractStorageLib.getTotalAvailableValidators() - oldAvailableCount) + newAvailableCount\n            );\n        }\n    }\n\n    function _addressToWithdrawalCredentials(address _recipient) internal pure returns (bytes32) {\n        return\n            bytes32(uint256(uint160(_recipient)) + 0x0100000000000000000000000000000000000000000000000000000000000000);\n    }\n\n    function _depositValidatorsOfOperator(\n        uint256 _operatorIndex,\n        uint256 _validatorCount,\n        address _withdrawer\n    ) internal {\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        StakingContractStorageLib.OperatorInfo storage operator = operators.value[_operatorIndex];\n        StakingContractStorageLib.ValidatorsFundingInfo memory vfi = StakingContractStorageLib.getValidatorsFundingInfo(\n            _operatorIndex\n        );\n\n        for (uint256 i = vfi.funded; i < vfi.funded + _validatorCount; ) {\n            bytes memory publicKey = operator.publicKeys[i];\n            bytes memory signature = operator.signatures[i];\n            address consensusLayerRecipient = _getDeterministicReceiver(publicKey, CONSENSUS_LAYER_SALT_PREFIX);\n            bytes32 withdrawalCredentials = _addressToWithdrawalCredentials(consensusLayerRecipient);\n            _depositValidator(publicKey, signature, withdrawalCredentials);\n            bytes32 pubkeyRoot = _getPubKeyRoot(publicKey);\n            StakingContractStorageLib.getWithdrawers().value[pubkeyRoot] = _withdrawer;\n            emit Deposit(msg.sender, _withdrawer, publicKey);\n            unchecked {\n                ++i;\n            }\n        }\n\n        StakingContractStorageLib.setValidatorsFundingInfo(\n            _operatorIndex,\n            uint32(vfi.availableKeys - _validatorCount),\n            uint32(vfi.funded + _validatorCount)\n        );\n    }\n\n    /// @notice Internal utility to deposit a public key, its signature and 32 ETH to the consensus layer\n    /// @param _publicKey The Public Key to deposit\n    /// @param _signature The Signature to deposit\n    /// @param _withdrawalCredentials The Withdrawal Credentials to deposit\n    function _depositValidator(\n        bytes memory _publicKey,\n        bytes memory _signature,\n        bytes32 _withdrawalCredentials\n    ) internal {\n        bytes32 pubkeyRoot = _getPubKeyRoot(_publicKey);\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(BytesLib.pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n            )\n        );\n\n        uint256 depositAmount = DEPOSIT_SIZE / 1000000000 wei;\n        assert(depositAmount * 1000000000 wei == DEPOSIT_SIZE);\n\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n                sha256(abi.encodePacked(Uint256Lib.toLittleEndian64(depositAmount), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - DEPOSIT_SIZE;\n\n        IDepositContract(StakingContractStorageLib.getDepositContract()).deposit{value: DEPOSIT_SIZE}(\n            _publicKey,\n            abi.encodePacked(_withdrawalCredentials),\n            _signature,\n            depositDataRoot\n        );\n\n        if (address(this).balance != targetBalance) {\n            revert DepositFailure();\n        }\n    }\n\n    function _depositOnOneOperator(\n        address _withdrawer,\n        uint256 _depositCount,\n        uint256 _totalAvailableValidators\n    ) internal {\n        _depositValidatorsOfOperator(0, _depositCount, _withdrawer);\n        StakingContractStorageLib.setTotalAvailableValidators(_totalAvailableValidators - _depositCount);\n    }\n\n    function _depositOnTwoOperators(\n        address _withdrawer,\n        uint256 _depositCount,\n        uint256 _totalAvailableValidators\n    ) internal {\n        StakingContractStorageLib.ValidatorsFundingInfo memory oneOsi = StakingContractStorageLib\n            .getValidatorsFundingInfo(0);\n        StakingContractStorageLib.ValidatorsFundingInfo memory twoOsi = StakingContractStorageLib\n            .getValidatorsFundingInfo(1);\n\n        uint256 oneDepositCount;\n        uint256 twoDepositCount;\n\n        // using this tactic to prevent deposits of 1 validator to always go to operator 2\n        if (block.number % 2 == 0) {\n            oneDepositCount = _depositCount / 2;\n            twoDepositCount = _depositCount - oneDepositCount;\n        } else {\n            twoDepositCount = _depositCount / 2;\n            oneDepositCount = _depositCount - twoDepositCount;\n        }\n\n        if (oneDepositCount > oneOsi.availableKeys) {\n            twoDepositCount = _depositCount - oneOsi.availableKeys;\n            oneDepositCount = oneOsi.availableKeys;\n        } else if (twoDepositCount > twoOsi.availableKeys) {\n            oneDepositCount = _depositCount - twoOsi.availableKeys;\n            twoDepositCount = twoOsi.availableKeys;\n        }\n\n        if (oneDepositCount > 0) {\n            _depositValidatorsOfOperator(0, oneDepositCount, _withdrawer);\n        }\n        if (twoDepositCount > 0) {\n            _depositValidatorsOfOperator(1, twoDepositCount, _withdrawer);\n        }\n        StakingContractStorageLib.setTotalAvailableValidators(\n            _totalAvailableValidators - (oneDepositCount + twoDepositCount)\n        );\n    }\n\n    function _getBaseSkip(\n        bytes32 blockHash,\n        uint256 index,\n        uint8 prime\n    ) internal pure returns (uint8 base, uint8 skip) {\n        base = uint8(blockHash[(index * 2) % 32]) % prime;\n        skip = (uint8(blockHash[((index * 2) + 1) % 32]) % (prime - 1)) + 1;\n    }\n\n    function _getOperatorFundedCount(uint8 operatorIndex, ValidatorAllocationCache[] memory vd)\n        internal\n        view\n        returns (uint32)\n    {\n        if (operatorIndex >= vd.length) {\n            return 0;\n        }\n        if (vd[operatorIndex].used == false) {\n            StakingContractStorageLib.ValidatorsFundingInfo memory osi = StakingContractStorageLib\n                .getValidatorsFundingInfo(operatorIndex);\n            vd[operatorIndex].used = true;\n            vd[operatorIndex].funded = osi.funded;\n            vd[operatorIndex].available = osi.availableKeys;\n        }\n        return vd[operatorIndex].funded + vd[operatorIndex].toDeposit;\n    }\n\n    function _getOperatorAvailableCount(uint8 operatorIndex, ValidatorAllocationCache[] memory vd)\n        internal\n        view\n        returns (uint32)\n    {\n        if (operatorIndex >= vd.length) {\n            return 0;\n        }\n        if (vd[operatorIndex].used == false) {\n            StakingContractStorageLib.ValidatorsFundingInfo memory osi = StakingContractStorageLib\n                .getValidatorsFundingInfo(operatorIndex);\n            vd[operatorIndex].used = true;\n            vd[operatorIndex].funded = osi.funded;\n            vd[operatorIndex].available = osi.availableKeys;\n        }\n        return vd[operatorIndex].available - vd[operatorIndex].toDeposit;\n    }\n\n    function _assignTemporaryDeposit(uint8 operatorIndex, ValidatorAllocationCache[] memory vd) internal pure {\n        vd[operatorIndex].toDeposit += 1;\n    }\n\n    function _getBestOperator(\n        uint8 alphaIndex,\n        uint8 betaIndex,\n        bytes32 blockHash,\n        ValidatorAllocationCache[] memory vd\n    ) internal view returns (uint8) {\n        uint256 alphaFundedCount = _getOperatorFundedCount(alphaIndex, vd);\n        uint256 betaFundedCount = _getOperatorFundedCount(betaIndex, vd);\n        if (alphaFundedCount < betaFundedCount) {\n            return alphaIndex;\n        } else if (alphaFundedCount > betaFundedCount) {\n            return betaIndex;\n        } else {\n            bool coinToss = (uint8(blockHash[(alphaIndex + betaIndex) % 32]) % 2) == 1;\n            if (coinToss == false) {\n                return betaIndex;\n            } else {\n                return alphaIndex;\n            }\n        }\n    }\n\n    function _getElligibleOperators(\n        uint8 base,\n        uint8 skip,\n        uint8 prime,\n        ValidatorAllocationCache[] memory vd\n    ) internal view returns (uint8, uint8) {\n        int16 alphaIndex = -1;\n        int16 betaIndex = -1;\n        uint8 index = base;\n        while (alphaIndex == -1 || betaIndex == -1) {\n            if (_getOperatorAvailableCount(index, vd) > 0) {\n                if (alphaIndex == -1) {\n                    alphaIndex = int8(index);\n                } else {\n                    betaIndex = int8(index);\n                }\n            }\n            index = (index + skip) % prime;\n            if (index == base && betaIndex == -1) {\n                betaIndex = alphaIndex;\n            }\n        }\n        return (uint8(int8(alphaIndex)), uint8(int8(betaIndex)));\n    }\n\n    function _depositOnThreeOrMoreOperators(\n        address _withdrawer,\n        uint256 _depositCount,\n        uint256 _totalAvailableValidators,\n        StakingContractStorageLib.OperatorsSlot storage _operators\n    ) internal {\n        uint256 operatorCount = _operators.value.length;\n        uint8 optimusPrime = _getClosestPrimeAbove(uint8(operatorCount));\n        bytes32 blockHash = blockhash(block.number); // weak random number as it's not a security issue\n\n        ValidatorAllocationCache[] memory vd = new ValidatorAllocationCache[](operatorCount);\n\n        for (uint256 index; index < _depositCount; ) {\n            // Retrieve base index and skip value based on block hash and current loop index\n            (uint8 base, uint8 skip) = _getBaseSkip(blockHash, index, optimusPrime);\n            // Retrieve two operator indexes pointing to two (or the same) operator(s) that have at least one available\n            // validator key to be used for a deposit. This method takes into account possible pending deposits from\n            // previous loop rounds.\n            (uint8 alphaIndex, uint8 betaIndex) = _getElligibleOperators(base, skip, optimusPrime, vd);\n\n            if (alphaIndex == betaIndex) {\n                // Assign the deposit to the only operator having available keys\n                _assignTemporaryDeposit(alphaIndex, vd);\n            } else {\n                // Assign the deposit to the operator having the lowest amount of funded keys\n                _assignTemporaryDeposit(_getBestOperator(alphaIndex, betaIndex, blockHash, vd), vd);\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        // Loop through the cached operator values and deposit any pending deposits\n        for (uint256 index; index < vd.length; ) {\n            if (vd[index].toDeposit > 0) {\n                _depositValidatorsOfOperator(index, vd[index].toDeposit, _withdrawer);\n            }\n            unchecked {\n                ++index;\n            }\n        }\n\n        StakingContractStorageLib.setTotalAvailableValidators(_totalAvailableValidators - _depositCount);\n    }\n\n    function _deposit(address _withdrawer) internal {\n        if (msg.value == 0 || msg.value % DEPOSIT_SIZE != 0) {\n            revert InvalidDepositValue();\n        }\n        uint256 totalAvailableValidators = StakingContractStorageLib.getTotalAvailableValidators();\n        uint256 depositCount = msg.value / DEPOSIT_SIZE;\n        if (depositCount > totalAvailableValidators) {\n            revert NotEnoughValidators();\n        }\n        StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n        if (operators.value.length == 0) {\n            revert NoOperators();\n        } else if (operators.value.length == 1) {\n            _depositOnOneOperator(_withdrawer, depositCount, totalAvailableValidators);\n        } else if (operators.value.length == 2) {\n            _depositOnTwoOperators(_withdrawer, depositCount, totalAvailableValidators);\n        } else {\n            _depositOnThreeOrMoreOperators(_withdrawer, depositCount, totalAvailableValidators, operators);\n        }\n    }\n\n    function _primes() internal pure returns (uint8[54] memory primes) {\n        primes = [\n            2,\n            3,\n            5,\n            7,\n            11,\n            13,\n            17,\n            19,\n            23,\n            29,\n            31,\n            37,\n            41,\n            43,\n            47,\n            53,\n            59,\n            61,\n            67,\n            71,\n            73,\n            79,\n            83,\n            89,\n            97,\n            101,\n            103,\n            107,\n            109,\n            113,\n            127,\n            131,\n            137,\n            139,\n            149,\n            151,\n            157,\n            163,\n            167,\n            173,\n            179,\n            181,\n            191,\n            193,\n            197,\n            199,\n            211,\n            223,\n            227,\n            229,\n            233,\n            239,\n            241,\n            251\n        ];\n    }\n\n    function _getClosestPrimeAbove(uint8 _count) internal pure returns (uint8) {\n        uint8[54] memory primes = _primes();\n        for (uint256 i; i < primes.length; ) {\n            if (primes[i] >= _count) {\n                return primes[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        revert InvalidValidatorCount();\n    }\n\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        if (_a < _b) {\n            return _a;\n        }\n        return _b;\n    }\n\n    /// @notice Internal utility to compute the receiver deterministic address\n    /// @param _publicKey Public Key assigned to the receiver\n    /// @param _prefix Prefix used to generate multiple receivers per public key\n    function _getDeterministicReceiver(bytes memory _publicKey, uint256 _prefix) internal view returns (address) {\n        bytes32 publicKeyRoot = _getPubKeyRoot(_publicKey);\n        bytes32 salt = sha256(abi.encodePacked(_prefix, publicKeyRoot));\n        address implementation = StakingContractStorageLib.getFeeRecipientImplementation();\n        return Clones.predictDeterministicAddress(implementation, salt);\n    }\n\n    /// @notice Internal utility to deploy and withdraw the fees from a receiver\n    /// @param _publicKey Public Key assigned to the receiver\n    /// @param _prefix Prefix used to generate multiple receivers per public key\n    /// @param _dispatcher Address of the dispatcher contract\n    function _deployAndWithdraw(\n        bytes calldata _publicKey,\n        uint256 _prefix,\n        address _dispatcher\n    ) internal {\n        bytes32 publicKeyRoot = _getPubKeyRoot(_publicKey);\n        bytes32 feeRecipientSalt = sha256(abi.encodePacked(_prefix, publicKeyRoot));\n        address implementation = StakingContractStorageLib.getFeeRecipientImplementation();\n        address feeRecipientAddress = Clones.predictDeterministicAddress(implementation, feeRecipientSalt);\n        if (feeRecipientAddress.code.length == 0) {\n            Clones.cloneDeterministic(implementation, feeRecipientSalt);\n            IFeeRecipient(feeRecipientAddress).init(_dispatcher, publicKeyRoot);\n        }\n        IFeeRecipient(feeRecipientAddress).withdraw();\n    }\n}\n"
    },
    "src/contracts/libs/UintLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary Uint256Lib {\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 temp_value = _value;\n        for (uint256 i = 0; i < 8; ++i) {\n            result = (result << 8) | (temp_value & 0xFF);\n            temp_value >>= 8;\n        }\n\n        assert(0 == temp_value); // fully converted\n        result <<= (24 * 8);\n    }\n}\n"
    },
    "src/contracts/libs/BytesLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary BytesLib {\n    function pad64(bytes memory _b) internal pure returns (bytes memory) {\n        assert(_b.length >= 32 && _b.length <= 64);\n        if (64 == _b.length) return _b;\n\n        bytes memory zero32 = new bytes(32);\n        assembly {\n            mstore(add(zero32, 0x20), 0)\n        }\n\n        if (32 == _b.length) return BytesLib.concat(_b, zero32);\n        else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64) - _b.length));\n    }\n\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "src/contracts/interfaces/IFeeRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\ninterface IFeeRecipient {\n    function init(address _dispatcher, bytes32 _publicKeyRoot) external;\n\n    function withdraw() external;\n}\n"
    },
    "src/contracts/libs/StakingContractStorageLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\nlibrary StakingContractStorageLib {\n    function getUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setUint256(bytes32 position, uint256 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getAddress(bytes32 position) internal view returns (address data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setAddress(bytes32 position, address data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function getBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setBytes32(bytes32 position, bytes32 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant VERSION_SLOT = keccak256(\"StakingContract.version\");\n\n    function getVersion() internal view returns (uint256) {\n        return getUint256(VERSION_SLOT);\n    }\n\n    function setVersion(uint256 _newVersion) internal {\n        setUint256(VERSION_SLOT, _newVersion);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant ADMIN_SLOT = keccak256(\"StakingContract.admin\");\n\n    function getAdmin() internal view returns (address) {\n        return getAddress(ADMIN_SLOT);\n    }\n\n    function setAdmin(address _newAdmin) internal {\n        setAddress(ADMIN_SLOT, _newAdmin);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant TREASURY_SLOT = keccak256(\"StakingContract.treasury\");\n\n    function getTreasury() internal view returns (address) {\n        return getAddress(TREASURY_SLOT);\n    }\n\n    function setTreasury(address _newTreasury) internal {\n        setAddress(TREASURY_SLOT, _newTreasury);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant DEPOSIT_CONTRACT_SLOT = keccak256(\"StakingContract.depositContract\");\n\n    function getDepositContract() internal view returns (address) {\n        return getAddress(DEPOSIT_CONTRACT_SLOT);\n    }\n\n    function setDepositContract(address _newDepositContract) internal {\n        setAddress(DEPOSIT_CONTRACT_SLOT, _newDepositContract);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant OPERATORS_SLOT = keccak256(\"StakingContract.operators\");\n\n    struct OperatorInfo {\n        address operator;\n        address feeRecipient;\n        uint256 limit;\n        bytes[] publicKeys;\n        bytes[] signatures;\n        bool deactivated;\n    }\n\n    struct OperatorsSlot {\n        OperatorInfo[] value;\n    }\n\n    function getOperators() internal pure returns (OperatorsSlot storage p) {\n        bytes32 slot = OPERATORS_SLOT;\n        assembly {\n            p.slot := slot\n        }\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant VALIDATORS_FUNDING_INFO_SLOT = keccak256(\"StakingContract.validatorsFundingInfo\");\n\n    struct ValidatorsFundingInfo {\n        uint32 availableKeys;\n        uint32 funded;\n    }\n\n    struct UintToUintMappingSlot {\n        mapping(uint256 => uint256) value;\n    }\n\n    function getValidatorsFundingInfo(uint256 _index) internal view returns (ValidatorsFundingInfo memory vfi) {\n        UintToUintMappingSlot storage p;\n        bytes32 slot = VALIDATORS_FUNDING_INFO_SLOT;\n\n        assembly {\n            p.slot := slot\n        }\n\n        uint256 slotIndex = _index >> 2;\n        uint256 innerIndex = (_index & 3) << 6;\n        uint256 value = p.value[slotIndex] >> innerIndex;\n        vfi.availableKeys = uint32(value);\n        vfi.funded = uint32(value >> 32);\n    }\n\n    function setValidatorsFundingInfo(\n        uint256 _index,\n        uint32 _availableKeys,\n        uint32 _funded\n    ) internal {\n        UintToUintMappingSlot storage p;\n        bytes32 slot = VALIDATORS_FUNDING_INFO_SLOT;\n\n        assembly {\n            p.slot := slot\n        }\n\n        uint256 slotIndex = _index >> 2;\n        uint256 innerIndex = (_index & 3) << 6;\n        p.value[slotIndex] =\n            (p.value[slotIndex] & (~(uint256(0xFFFFFFFFFFFFFFFF) << innerIndex))) |\n            ((uint256(_availableKeys) | (uint256(_funded) << 32)) << innerIndex);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant TOTAL_AVAILABLE_VALIDATORS_SLOT = keccak256(\"StakingContract.totalAvailableValidators\");\n\n    function getTotalAvailableValidators() internal view returns (uint256) {\n        return getUint256(TOTAL_AVAILABLE_VALIDATORS_SLOT);\n    }\n\n    function setTotalAvailableValidators(uint256 _newTotal) internal {\n        setUint256(TOTAL_AVAILABLE_VALIDATORS_SLOT, _newTotal);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant WITHDRAWERS_SLOT = keccak256(\"StakingContract.withdrawers\");\n\n    struct WithdrawersSlot {\n        mapping(bytes32 => address) value;\n    }\n\n    function getWithdrawers() internal pure returns (WithdrawersSlot storage p) {\n        bytes32 slot = WITHDRAWERS_SLOT;\n        assembly {\n            p.slot := slot\n        }\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    struct OperatorIndex {\n        bool enabled;\n        uint32 operatorIndex;\n    }\n\n    struct OperatorIndexPerValidatorSlot {\n        mapping(bytes32 => OperatorIndex) value;\n    }\n\n    bytes32 internal constant OPERATOR_INDEX_PER_VALIDATOR_SLOT =\n        keccak256(\"StakingContract.operatorIndexPerValidator\");\n\n    function getOperatorIndexPerValidator() internal pure returns (OperatorIndexPerValidatorSlot storage p) {\n        bytes32 slot = OPERATOR_INDEX_PER_VALIDATOR_SLOT;\n        assembly {\n            p.slot := slot\n        }\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant GLOBAL_FEE_SLOT = keccak256(\"StakingContract.globalFee\");\n\n    function getGlobalFee() internal view returns (uint256) {\n        return getUint256(GLOBAL_FEE_SLOT);\n    }\n\n    function setGlobalFee(uint256 _newTreasuryFee) internal {\n        setUint256(GLOBAL_FEE_SLOT, _newTreasuryFee);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant OPERATOR_FEE_SLOT = keccak256(\"StakingContract.operatorFee\");\n\n    function getOperatorFee() internal view returns (uint256) {\n        return getUint256(OPERATOR_FEE_SLOT);\n    }\n\n    function setOperatorFee(uint256 _newOperatorFee) internal {\n        setUint256(OPERATOR_FEE_SLOT, _newOperatorFee);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant EL_DISPATCHER_SLOT = keccak256(\"StakingContract.executionLayerDispatcher\");\n\n    function getELDispatcher() internal view returns (address) {\n        return getAddress(EL_DISPATCHER_SLOT);\n    }\n\n    function setELDispatcher(address _newElDispatcher) internal {\n        setAddress(EL_DISPATCHER_SLOT, _newElDispatcher);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant CL_DISPATCHER_SLOT = keccak256(\"StakingContract.consensusLayerDispatcher\");\n\n    function getCLDispatcher() internal view returns (address) {\n        return getAddress(CL_DISPATCHER_SLOT);\n    }\n\n    function setCLDispatcher(address _newClDispatcher) internal {\n        setAddress(CL_DISPATCHER_SLOT, _newClDispatcher);\n    }\n\n    /* ========================================\n    ===========================================\n    =========================================*/\n\n    bytes32 internal constant FEE_RECIPIENT_IMPLEMENTATION_SLOT =\n        keccak256(\"StakingContract.feeRecipientImplementation\");\n\n    function getFeeRecipientImplementation() internal view returns (address) {\n        return getAddress(FEE_RECIPIENT_IMPLEMENTATION_SLOT);\n    }\n\n    function setFeeRecipientImplementation(address _newFeeRecipientImplementation) internal {\n        setAddress(FEE_RECIPIENT_IMPLEMENTATION_SLOT, _newFeeRecipientImplementation);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}